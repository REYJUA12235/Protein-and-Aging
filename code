###############################################################################
# Association of dietary protein intake with accelerated biological aging
# and all-cause & cause-specific mortality
#
# Analysis authors: Juan Reyes Barrera and Neftalí E. A. Villa
# Latest version: 2025-11-01
# Contact: reyesbarrera_juan@hotmail.com
###############################################################################

#### ---- 0. Setup: packages and options ---- ####
# Install packages if needed (uncomment)
# install.packages(c("tidyverse","haven","readxl","survival","broom","gtsummary","flextable","officer","GGally","kableExtra"))

library(tidyverse)
library(haven)
library(readxl)
library(survival)
library(broom)
library(gtsummary)
library(kableExtra)
library(flextable)
library(officer)
library(GGally)
library(gridExtra)

options(stringsAsFactors = FALSE)
theme_set(theme_minimal())

#### ---- 1. Import NHANES .sav files from folder ---- ####
# set this to your folder path (windows example)
ruta_carpeta <- "C:/Users/Usuario/Desktop/Analisis proteinas/analisis_proteinas_compartido"

# List .sav files and import all into a named list
sav_files <- list.files(path = ruta_carpeta, pattern = "\\.sav$", full.names = TRUE)
if(length(sav_files) == 0) stop("No .sav files found in ruta_carpeta. Check the path.")

nhanes_list <- setNames(lapply(sav_files, read_sav), tools::file_path_sans_ext(basename(sav_files)))

# OPTIONAL: rename by label if desired (best to rely on original variable names)
# ------------------------------------------------------------
# If you prefer to keep original column names, skip any automatic relabeling.
# The following block is commented because aggressive relabeling can break variable names.
# ------------------------------------------------------------
# nhanes_list <- lapply(nhanes_list, function(df){
#   # keep as is to avoid name collisions; users confirmed variable names exist
#   df
# })

#### ---- 2. Harmonize / combine datasets (example using common tables) ---- ####
# The next section assumes you have objects like BMX, BMX_B, DEMO, DEMO_B etc. If your .sav files are named differently,
# either adapt names or combine files directly. We'll try a generic approach: bind rows for files that appear to be cycles.
# If your dataset already has combined objects from earlier, skip to merging section.

# Example: find common tables by filename patterns (you may adapt)
# For reproducibility we will assume the user already loaded the cycle-specific objects earlier,
# but if not, we show a safe pattern to combine by variable intersection.

# Create a single combined dataframe by left-joining the most important tables by participant ID.
# We will look for common ID variable names and attempt to merge.

# Attempt to find the main participant ID column name from loaded frames:
possible_id_names <- c("SEQN", "ID", "id")
found_id <- NULL
for(df in nhanes_list){
  nm <- intersect(possible_id_names, names(df))
  if(length(nm)) { found_id <- nm[1]; break }
}
if(is.null(found_id)) found_id <- "SEQN" # fallback; adjust if needed

# If your files already correspond to specific NHANES datasets (BMX, DEMO, TELO, etc), you should create objects with those names.
# For safety, we build df_all by left joining the biggest tables using SEQN/ID when present.

# Pick a large "base" dataset (the first loaded) and left_join the others on the chosen ID
df_all <- nhanes_list[[1]]
if(!found_id %in% names(df_all)) {
  # try heuristics: use first column as ID
  found_id <- names(df_all)[1]
  message("Using ", found_id, " as participant ID (heuristic). Validate this is correct.")
}
for(i in 2:length(nhanes_list)){
  other <- nhanes_list[[i]]
  if(found_id %in% names(other)){
    df_all <- df_all %>% left_join(other, by = found_id)
  } else {
    # skip or join by alternative - user may adapt
    warning("Skipping join for file: ", names(nhanes_list)[i], " (no ID column found).")
  }
}

# rename df_all to df_final to keep original script logic
df_final <- df_all

#### ---- 3. Initial filters and core variable checks ---- ####
# Keep adults > 20 y
if(!("Age at Screening Adjudicated - Recode" %in% names(df_final))) {
  stop("Variable 'Age at Screening Adjudicated - Recode' not found in df_final. Rename as necessary.")
}
df_final <- df_final %>% filter(`Age at Screening Adjudicated - Recode` > 20)

# Ensure required dietary & biomarker variables exist (user confirmed names)
required_vars <- c("Protein (gm)", "Mean T/S ratio", "Energy (kcal)",
                   "Carbohydrate (gm)", "Total fat (gm)","Weight (kg)",
                   "Standing Height (cm)", "Waist Circumference (cm)",
                   "Gender", "Race/Ethnicity - Recode")
missing_vars <- setdiff(required_vars, names(df_final))
if(length(missing_vars) > 0) stop("Missing required variables: ", paste(missing_vars, collapse = ", "))

# Keep rows with non-missing protein and telomere
df_final <- df_final %>%
  filter(!is.na(`Protein (gm)`), !is.na(`Mean T/S ratio`))

#### ---- 4. Recode & clean key covariates ---- ####
# Ethnicity: recode to 'White','Black','Mexican-American','Other'
df_final <- df_final %>%
  mutate(
    `Race/Ethnicity - Recode` = factor(`Race/Ethnicity - Recode`),
    Ethnicity = case_when(
      `Race/Ethnicity - Recode` %in% c("Non-Hispanic White") ~ "White",
      `Race/Ethnicity - Recode` %in% c("Non-Hispanic Black") ~ "Black",
      `Race/Ethnicity - Recode` %in% c("Mexican-American") ~ "Mexican-American",
      TRUE ~ "Other"
    ) %>%
      factor(levels = c("White","Black","Mexican-American","Other"))
  )

# Gender: ensure levels "Women","Men"
if(!"Gender" %in% names(df_final)) stop("'Gender' variable not found.")
df_final <- df_final %>% mutate(Gender = recode(as.character(Gender), `1` = "Men", `2` = "Women"))
df_final$Gender <- factor(df_final$Gender, levels = c("Women", "Men"))

# Create standing height in meters if only cm present
if("Standing Height (cm)" %in% names(df_final)){
  df_final <- df_final %>% mutate(`Standing Height (m)` = `Standing Height (cm)` / 100)
}

# Create energy-related variables and protein per kg
df_final <- df_final %>%
  mutate(
    protein_g_per_day = `Protein (gm)`,
    Energy_kcal = `Energy (kcal)`,
    protein_per_kg_per_day = `Protein (gm)` / `Weight (kg)`,
    # Protein per kg IBW: IBW rules per your description
    BMI = ifelse(!is.na(`Weight (kg)`) & !is.na(`Standing Height (m)`),
                 `Weight (kg)` / (`Standing Height (m)`^2), NA),
    IBW = case_when(
      BMI >= 25 ~ 24.9 * (`Standing Height (m)`^2),
      BMI < 18.5 ~ 18.5 * (`Standing Height (m)`^2),
      TRUE ~ `Weight (kg)`
    ),
    protein_per_kg_IBW_per_day = protein_g_per_day / IBW
  )

# protein adequacy
df_final <- df_final %>%
  mutate(protein_status = ifelse(protein_per_kg_per_day >= 0.8, "Adequate (>=0.8 g/kg/day)", "Inadequate (<0.8 g/kg/day)"))

# create quintiles for protein per kg/day (consistent with your earlier names)
df_final <- df_final %>%
  mutate(
    Protein_Quintiles_Num = ntile(protein_per_kg_per_day, 5),
    Protein_kg_day_Quintile = factor(Protein_Quintiles_Num,
                                     levels = 1:5,
                                     labels = c("Q1 (lowest)", "Q2", "Q3", "Q4", "Q5 (highest)"))
  )

#### ---- 5. Biological aging metrics ---- ####
# We assume the user has functions/packages for anthropoage, phenoage, kdm.
# The user confirmed biomarker names to use: telomere_ratio, anthropoage, phenoage, kdm
# Map existing variables to these names if needed.
# If your df_final already has those exact names, this will do nothing.

if("Mean T/S ratio" %in% names(df_final)) df_final <- df_final %>% rename(telomere_ratio = `Mean T/S ratio`)
if("AnthropoAge" %in% names(df_final)) df_final <- df_final %>% rename(anthropoage = AnthropoAge)
if("Phenoage" %in% names(df_final)) df_final <- df_final %>% rename(phenoage = Phenoage)
if("kdm" %in% names(df_final)) df_final <- df_final %>% rename(kdm = kdm)

# If any metric missing, attempt to compute (user must have relevant functions/packages)
# Example placeholders (uncomment and adapt if you have these functions)
# df_final <- df_final %>% mutate(
#   anthropoage = AnthropoAgeR::s_anthropoage(Age= `Age at Screening Adjudicated - Recode`, Sex = Gender, Weight = `Weight (kg)`, Waist = `Waist Circumference (cm)`, Height = `Standing Height (m)`, Ethnicity = Ethnicity),
#   phenoage = phenoage_function(...) ,
#   kdm = kdm_nhanes(...)
# )

# Quick checks
if(!all(c("telomere_ratio","anthropoage","phenoage","kdm") %in% names(df_final))){
  warning("One or more biological age metrics are missing from df_final. Please compute them and re-run. Current available: ", paste(intersect(names(df_final), c("telomere_ratio","anthropoage","phenoage","kdm")), collapse=", "))
}

#### ---- 6. Acceleration metrics (continuous + categorical) ---- ####
# Compute age acceleration: BA - expected (here we use simple residual approach: residuals from regressing BA on chronological age)
# or use specialized functions if available (you referenced AnthropoAgeR::age_accel etc.)
df_final <- df_final %>%
  mutate(
    chron_age = `Age at Screening Adjudicated - Recode`,
    accel_anthropo = residuals(lm(anthropoage ~ chron_age + Gender, data = df_final)),
    accel_pheno = residuals(lm(phenoage ~ chron_age + Gender, data = df_final)),
    accel_kdm   = residuals(lm(kdm ~ chron_age + Gender, data = df_final))
  )

# categorical accelerated vs non-accelerated (>=0 -> accelerated)
df_final <- df_final %>%
  mutate(
    accel_category_anthr = ifelse(accel_anthropo >= 0, "Aging Accelerated", "Aging Non-Accelerated"),
    accel_category_phe   = ifelse(accel_pheno >= 0, "Aging Accelerated", "Aging Non-Accelerated"),
    accel_category_kdm   = ifelse(accel_kdm >= 0,   "Aging Accelerated", "Aging Non-Accelerated"),
    Telomere_status = ifelse(telomere_ratio < quantile(telomere_ratio, 0.25, na.rm = TRUE), "Low (<P25)", "High (≥P25)")
  )

#### ---- 7. Descriptive table: Supplementary Table 5 ---- ####
df_desc <- df_final %>%
  mutate(
    Energy_from_Protein = protein_g_per_day * 4,
    Energy_from_Carbohydrates = `Carbohydrate (gm)` * 4,
    Energy_from_Fat = `Total fat (gm)` * 9,
    Pct_Protein_from_Total = (Energy_from_Protein / Energy_kcal) * 100,
    Pct_Carb_from_Total = (Energy_from_Carbohydrates / Energy_kcal) * 100,
    Pct_Fat_from_Total = (Energy_from_Fat / Energy_kcal) * 100
  )

vars_table5 <- c("Energy_kcal", "Energy_from_Carbohydrates", "Pct_Carb_from_Total","Carbohydrate (gm)",
                 "Energy_from_Fat","Pct_Fat_from_Total","Total fat (gm)",
                 "Energy_from_Protein","Pct_Protein_from_Total","protein_g_per_day",
                 "protein_per_kg_per_day","protein_per_kg_IBW_per_day","protein_status")

# gtsummary table with median (IQR) and n(%)
table_supp5 <- df_desc %>%
  select(all_of(vars_table5)) %>%
  tbl_summary(
    statistic = list(all_continuous() ~ "{median} ({p25}–{p75})",
                     all_categorical() ~ "{n} ({p}%)"),
    digits = all_continuous() ~ 2,
    missing = "no"
  ) %>%
  bold_labels()

# Print and save
table_supp5
as_flextable(table_supp5) %>% flextable::save_as_docx(path = "Supplementary_Table_5.docx")

#### ---- 8. Supplementary Table 6: Age-stratified linear models (interaction test) ---- ####
# Age groups must be present as Age_group2 with <40, 40–60, >60
if(!"Age_group2" %in% names(df_final)) stop("Age_group2 not found in df_final. Create it and rerun.")

covariates_model <- c("Gender","residuos","Energy_kcal","Race/Ethnicity - Recode",
                      "Doctor told you have diabetes","Activity level","Ever told you had high blood pressure",
                      "Do you now smoke cigarettes","Family PIR")

# safe function to fit and extract for a marker
fit_stratified <- function(data, outcome_var){
  data %>%
    group_by(Age_group2) %>%
    group_modify(~{
      frm <- as.formula(paste0(outcome_var, " ~ protein_per_kg_per_day + ", paste(covariates_model, collapse = " + ")))
      m <- try(lm(frm, data = .x), silent = TRUE)
      if(inherits(m,"try-error")) return(tibble(estimate=NA, conf.low=NA, conf.high=NA, p.value=NA))
      t <- broom::tidy(m, conf.int=TRUE) %>% filter(term == "protein_per_kg_per_day")
      tibble(estimate = t$estimate, conf.low = t$conf.low, conf.high = t$conf.high, p.value = t$p.value)
    }) %>%
    ungroup() %>%
    mutate(Marker = outcome_var)
}

markers_list <- c("telomere_ratio","anthropoage","phenoage","kdm")
supp6_list <- map_df(markers_list, ~fit_stratified(df_final, .x))

# Interaction p-values (vs <40)
interaction_tests <- map_df(markers_list, function(marker){
  frm <- as.formula(paste0(marker, " ~ protein_per_kg_per_day * Age_group2 + ", paste(covariates_model, collapse = " + ")))
  m <- lm(frm, data = df_final)
  t <- broom::tidy(m)
  # extract interaction terms
  t_int <- t %>% filter(grepl("protein_per_kg_per_day:Age_group2", term)) %>%
    mutate(Marker = marker) %>%
    select(Marker, term, p.value)
  t_int
})

# Join and format like Supplementary Table 6
supp6_out <- supp6_list %>%
  left_join(interaction_tests, by = c("Marker" = "Marker")) %>%
  mutate(
    Beta_CI = sprintf("%.3f (%.3f, %.3f)", estimate, conf.low, conf.high),
    Sig = ifelse(p.value.x < 0.05, "*", "")
  ) %>%
  select(Marker, Age_group2, Beta_CI, Sig, p.value.x, term, p.value.y)

# save
write.csv(supp6_out, "Supplementary_Table_6_age_stratified.csv", row.names = FALSE)

#### ---- 9. Supplementary Table 7: Linear models for continuous protein (g/kg/day) and quintiles ---- ####
# We'll fit adjusted linear models (Model 1 and Model 2 per your description).
# Model 1: adjust for age (residual), sex, energy from carbohydrates, ethnicity, poverty ratio, tobacco, physical activity, hypertension, diabetes
# Model 2: same but energy from fat instead of energy from carbohydrates

# Ensure covariates exist or adapt names
# We'll create Model1 and Model2 formulas programmatically
model1_covs <- c("residuos", "Gender", "Energy_kcal", "Race/Ethnicity - Recode", "Family PIR", "Do you now smoke cigarettes", "Activity level", "Ever told you had high blood pressure", "Doctor told you have diabetes")
# In Model 1 energy from carbs: we will pass Energy_kcal but the user wanted 'Energy from carbohydrates' specifically. Create if not present:
df_final <- df_final %>% mutate(Energy_from_Carbohydrates = `Carbohydrate (gm)` * 4, Energy_from_Fat = `Total fat (gm)` * 9)

# Build formula helper
fit_models_for_marker <- function(data, marker){
  # continuous exposure (protein_per_kg_per_day)
  f1 <- as.formula(paste(marker, "~ protein_per_kg_per_day +", paste(c("residuos","Gender","Energy_from_Carbohydrates","Ethnicity","Family_PIR","Do you now smoke cigarettes","Activity level","Ever told you had high blood pressure","Doctor told you have diabetes"), collapse = " + ")))
  f2 <- as.formula(paste(marker, "~ protein_per_kg_per_day +", paste(c("residuos","Gender","Energy_from_Fat","Ethnicity","Family_PIR","Do you now smoke cigarettes","Activity level","Ever told you had high blood pressure","Doctor told you have diabetes"), collapse = " + ")))
  m1 <- lm(f1, data = data)
  m2 <- lm(f2, data = data)
  # quintile models (Protein_kg_day_Quintile)
  q1 <- as.formula(paste(marker, "~ Protein_kg_day_Quintile +", paste(c("residuos","Gender","Energy_from_Carbohydrates","Ethnicity","Family_PIR","Do you now smoke cigarettes","Activity level","Ever told you had high blood pressure","Doctor told you have diabetes"), collapse = " + ")))
  q2 <- as.formula(paste(marker, "~ Protein_kg_day_Quintile +", paste(c("residuos","Gender","Energy_from_Fat","Ethnicity","Family_PIR","Do you now smoke cigarettes","Activity level","Ever told you had high blood pressure","Doctor told you have diabetes"), collapse = " + ")))
  mq1 <- lm(q1, data = data)
  mq2 <- lm(q2, data = data)
  list(m1 = m1, m2 = m2, mq1 = mq1, mq2 = mq2)
}

# Fit models for each marker and extract the protein_per_kg_per_day coefficient
results_supp7 <- map_df(markers_list, function(marker){
  fits <- fit_models_for_marker(df_final, marker)
  # continuous coefficients
  tidy_m1 <- broom::tidy(fits$m1, conf.int = TRUE) %>% filter(term == "protein_per_kg_per_day") %>% mutate(Model = "Model1 (carb adj)", Marker = marker)
  tidy_m2 <- broom::tidy(fits$m2, conf.int = TRUE) %>% filter(term == "protein_per_kg_per_day") %>% mutate(Model = "Model2 (fat adj)", Marker = marker)
  # quintile coefficients (we extract Q2..Q5)
  tidy_mq1 <- broom::tidy(fits$mq1, conf.int = TRUE) %>% filter(grepl("Protein_kg_day_Quintile", term)) %>% mutate(Model = "Model1 (carb adj)", Marker = marker)
  tidy_mq2 <- broom::tidy(fits$mq2, conf.int = TRUE) %>% filter(grepl("Protein_kg_day_Quintile", term)) %>% mutate(Model = "Model2 (fat adj)", Marker = marker)
  bind_rows(tidy_m1, tidy_m2, tidy_mq1, tidy_mq2)
})

# Format results table
results_supp7 <- results_supp7 %>%
  mutate(
    estimate = round(estimate, 3),
    conf.low = round(conf.low, 3),
    conf.high = round(conf.high, 3),
    Beta_CI = sprintf("%.3f (%.3f, %.3f)", estimate, conf.low, conf.high),
    p_value = signif(p.value, 3)
  ) %>%
  select(Marker, Model, term, Beta_CI, p_value)

write.csv(results_supp7, "Supplementary_Table_7_results.csv", row.names = FALSE)

#### ---- 10. Figure 2: Forest plot for logistic results (accelerated aging, adjusted models) ---- ####
# Fit logistic models for accelerated aging outcomes (examples)
log_outcomes <- c(Anthropo = "accel_category_anthr", Pheno = "accel_category_phe", KDM = "accel_category_kdm", Telomere = "Telomere_status")

fit_logistic <- function(outcome_var){
  f <- as.formula(paste0(outcome_var, " ~ protein_per_kg_per_day + residuos + Gender + Energy_from_Carbohydrates + Ethnicity + Family_PIR + `Do you now smoke cigarettes` + `Activity level` + `Ever told you had high blood pressure` + `Doctor told you have diabetes`"))
  glm(f, data = df_final, family = binomial)
}

# build results for forest plot (odds ratios)
log_results <- map_df(log_outcomes, function(o){
  model <- fit_logistic(o)
  tidy(model, conf.int = TRUE, exponentiate = TRUE) %>%
    filter(term == "protein_per_kg_per_day") %>%
    mutate(Outcome = o)
})

# plot
if(nrow(log_results) > 0){
  log_results <- log_results %>% mutate(term = "protein (g/kg/day)")
  ggplot(log_results, aes(x = Outcome, y = estimate, ymin = conf.low, ymax = conf.high)) +
    geom_pointrange() +
    geom_hline(yintercept = 1, linetype = "dashed") +
    coord_flip() +
    labs(y = "Odds Ratio (95% CI)", x = "", title = "Odds of accelerated biological aging per 1 g/kg/day protein (adjusted)")
}

#### ---- 11. Supplementary Table 8 & Table 4: Cox models for all-cause and cause-specific mortality ---- ####
# Ensure survival outcome variables exist: permth_int (follow-up months), mortstat (all-cause event), cause-specific variables (Heart_diseases, Cerebrovascular_diseases, Malignant_neoplasms)
if(!all(c("permth_int","mortstat") %in% names(df_final))) warning("permth_int or mortstat missing: update names accordingly.")

# Use df_final as df_filter3 for consistency
df_filter3 <- df_final

# Recode some covariates to short names for formula readability
df_filter3 <- df_filter3 %>% rename(
  Race = `Race/Ethnicity - Recode`,
  Diabetes_h = `Doctor told you have diabetes`,
  Activity = `Activity level`,
  Hypertension = `Ever told you had high blood pressure`,
  Smoking = `Do you now smoke cigarettes`,
  Family_PIR = `Family PIR`
)

# Helper to run and return tidy HR results for a list of models
get_hr <- function(model, label, type){
  broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
    select(term, estimate, conf.low, conf.high, p.value) %>%
    mutate(Model_label = label, Type = type)
}

# Build Cox models per your specification (unadjusted and adjusted)
surv_obj <- Surv(df_filter3$permth_int, df_filter3$mortstat)

# Define adjusted covariates vector used in models
adj_covariates <- c("Gender", "residuos", "Energy_kcal", "Race", "Family_PIR", "Diabetes_h", "Activity", "Hypertension", "Smoking")
adj_formula_rhs <- paste(adj_covariates, collapse = " + ")

# Function to build models for a given outcome (all-cause or cause-specific)
build_cox_models <- function(surv, outcome_var){
  # assume outcome_var is binary column 0/1 already; if not, user must adapt
  # Unadjusted models
  m_p_unadj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ protein_per_kg_per_day")), data = df_filter3)
  m_tl_unadj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ telomere_ratio")), data = df_filter3)
  m_p_tl_unadj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ protein_per_kg_per_day + telomere_ratio")), data = df_filter3)

  # Adjusted models
  m_p_adj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ protein_per_kg_per_day + ", adj_formula_rhs)), data = df_filter3)
  m_tl_adj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ telomere_ratio + ", adj_formula_rhs)), data = df_filter3)
  m_p_tl_adj <- coxph(as.formula(paste0("Surv(permth_int, ", outcome_var, ") ~ protein_per_kg_per_day + telomere_ratio + ", adj_formula_rhs)), data = df_filter3)

  list(
    p_unadj = m_p_unadj, tl_unadj = m_tl_unadj, p_tl_unadj = m_p_tl_unadj,
    p_adj = m_p_adj, tl_adj = m_tl_adj, p_tl_adj = m_p_tl_adj
  )
}

# Run for heart, cerebrovascular and cancer (ensure variable names exist)
cause_vars <- c("Heart_diseases", "Cerebrovascular_diseases", "Malignant_neoplasms")
all_cox_results <- list()
for(cv in cause_vars){
  if(!cv %in% names(df_filter3)) {
    warning(cv, " not found in df_filter3; skipping.")
    next
  }
  res_models <- build_cox_models(surv_obj, cv)
  # Extract HRs (adjusted only and unadjusted)
  res_tidy <- bind_rows(
    get_hr(res_models$p_unadj, paste0("Protein intake (", cv, ")"), "Unadjusted"),
    get_hr(res_models$p_adj, paste0("Protein intake (", cv, ")"), "Adjusted"),
    get_hr(res_models$tl_unadj, paste0("Telomere (", cv, ")"), "Unadjusted"),
    get_hr(res_models$tl_adj, paste0("Telomere (", cv, ")"), "Adjusted"),
    get_hr(res_models$p_tl_unadj, paste0("Protein + Telomere (", cv, ")"), "Unadjusted"),
    get_hr(res_models$p_tl_adj, paste0("Protein + Telomere (", cv, ")"), "Adjusted")
  ) %>% mutate(Outcome = cv)
  all_cox_results[[cv]] <- res_tidy
}

final_cox_table <- bind_rows(all_cox_results)
final_cox_table <- final_cox_table %>%
  mutate(HR_CI = sprintf("%.2f (%.2f – %.2f)", estimate, conf.low, conf.high),
         Sig = ifelse(p.value < 0.05, "*", "")) %>%
  select(Outcome, Model_label, Type, term, HR_CI, Sig, p.value)

# Save Supplementary Table 8
write.csv(final_cox_table, "Supplementary_Table_8_cox_results.csv", row.names = FALSE)

#### ---- 12. Mediation analysis skeleton (requires your mediation_ci1 function) ---- ####
# Check mediation function
if(!exists("mediation_ci1")){
  warning("mediation_ci1() not found in the environment. Please load or define this function to run mediation analyses. The script will skip mediation if it's unavailable.")
} else {
  mediators <- c("telomere_ratio","anthropoage","phenoage","kdm")
  outcomes_cause <- cause_vars
  exposure <- "protein_per_kg_per_day"
  mediation_results <- list()

  for(med in mediators){
    # model mediator ~ exposure + covs
    f_med <- as.formula(paste0("scale(", med, ") ~ scale(", exposure, ") + ", adj_formula_rhs))
    glm_med <- glm(f_med, data = df_filter3)
    for(outc in outcomes_cause){
      f_cox <- as.formula(paste0("Surv(permth_int, ", outc, ") ~ scale(", med, ") + scale(", exposure, ") + ", adj_formula_rhs))
      m_cox <- coxph(f_cox, data = df_filter3)
      # extract coefficients & variance as expected by your mediation function: adapt indices as necessary
      lambdas <- m_cox$coefficients
      lambdas.var <- m_cox$var
      # call mediation_ci1 (the signature used previously)
      med_res <- mediation_ci1(
        lambdas[2], lambdas[1],
        lambdas.var[2,2], lambdas.var[2,1], lambdas.var[1,1],
        glm_med$coef[2], vcov(glm_med)[2,2],
        G = 1e6, method = "Cox"
      )
      mediation_results[[paste(med, outc, sep = "_")]] <- med_res
    }
  }
  # combine if list elements are named-lists (user may need to adapt)
  # save mediation list as RDS
  saveRDS(mediation_results, file = "mediation_results_list.rds")
}

#### ---- 13. Supplementary analyses & correlation figure ---- ####
# Correlation matrix between chronological age and biological age metrics (Supplementary Figure 2)
df_corr <- df_final %>%
  select(chron_age, telomere_ratio, anthropoage, phenoage, kdm) %>%
  rename(ChronAge = chron_age, Telomere = telomere_ratio, AnthropoAge = anthropoage, PhenoAge = phenoage, KDM = kdm)

png("SuppFigure2_correlation_pairplot.png", width = 1600, height = 1200, res = 150)
ggpairs(df_corr,
        lower = list(continuous = wrap("points", alpha = 0.4)),
        upper = list(continuous = wrap("cor", size = 4)),
        diag = list(continuous = wrap("barDiag", bins = 20))) +
  theme_bw()
dev.off()

# Spearman correlations and p-values
cor_results <- map_df(c("Telomere","AnthropoAge","PhenoAge","KDM"), function(var){
  ct <- cor.test(df_corr[[var]], df_corr$ChronAge, method = "spearman", use = "complete.obs")
  tibble(Variable = var, rho = ct$estimate, p_value = ct$p.value)
})

write.csv(cor_results, "Supplementary_corr_results.csv", row.names = FALSE)

#### ---- 14. Save main results tables for manuscript / supplement ---- ####
write.csv(results_supp7, "Supplementary_Table_7.csv", row.names = FALSE)
# final_cox_table already saved above
# Table 2 (descriptives) — supply the gtsummary object as HTML / docx
table_supp5 %>% as_flex_table() %>% flextable::save_as_docx(path = "Supplementary_Table_5.docx")

#### ---- END ---- ####

# Notes:
# - This script is designed to be runnable end-to-end if the required NHANES files are placed in ruta_carpeta
#   and the expected variable names exist. Adjust variable names if your NHANES files use different labels.
# - The script includes protective checks and warnings; read messages during execution to adapt paths/names.
# - The mediation step requires your custom mediation_ci1() function to be present in the workspace.
# - If any specialized biological age calculation functions (AnthropoAgeR::s_anthropoage, phenoage, kdm_nhanes) are needed,
#   ensure the corresponding packages are installed and uncomment/adapt the placeholders above.
###############################################################################





